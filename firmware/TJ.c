/*

 TJ Gen1 prototype firmware source code

 Author:    Marius Popescu
   Date:    19.08.2014


   Copyright (C) 2014  Marius Popescu

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/


// Compile with Microchip XC8 compiler http://www.microchip.com/pagehandler/en_us/devtools/mplabxc/


// for PIC16LF1459 datasheet see: http://ww1.microchip.com/downloads/en/DeviceDoc/40001639B.pdf
#include <pic16lf1459.h>

// define OSC freqyency for delay routines
#define _XTAL_FREQ 16000000

// define config bits
#pragma config BOREN = OFF, IESO = OFF, FOSC = INTOSC, FCMEN = OFF, MCLRE = ON, WDTE = OFF, CP = OFF, PWRTE = OFF, CLKOUTEN = OFF, LVP = OFF, CPUDIV = NOCLKDIV, PLLEN = DISABLED


// include XC8 headers
#include <xc.h>


// bit manipulation macros
#define bit_test(byte, bit) ((byte) & (1 << bit))
#define bit_set(byte, bit) ((byte) |= (1 << bit))
#define bit_clear(byte, bit) ((byte) &= ~(1 << bit))
#define bit_toggle(byte, bit) ((byte) ^= (1 << bit))


// define the SPI module SS pin
#define SPI_SS    (LATCbits.LATC6)


// DAC voltage levels for the 5 symbol, dual-polarity PAM (Pulse Amplitude Modulation) used by TJ Gen1 prototype uplink
// PIC16LF1459 contains an internal 5bit DAC module (0 = 0.0V to 31 = VDD = 3.0V)

// SYNC symbol
#define     HS    16
#define     LS    15
// SYMBOL0 encoding 0b00
#define     H0    18
#define     L0    13
// SYMBOLl encoding 0b01
#define     H1    21
#define     L1    10
// SYMBOL2 encoding 0b10
#define     H2    25
#define     L2     6
// SYMBOL3 encoding 0b11
#define     H3    31
#define     L3     0


char    dac_frame1[14] = {HS,LS, HS,LS, HS,LS, HS,LS, HS,LS, HS,LS, HS,LS}, // data-packet buffer 1 initialized with SYNC symbols
        dac_frame2[14] = {HS,LS, HS,LS, HS,LS, HS,LS, HS,LS, HS,LS, HS,LS}, // data-packet buffer 2 initialized with SYNC symbols

        d6t_frame[520], // stores the data frame read from D6T-1616L over SPI
        dac_calc_new = 0,  // = 1 signals the frame_pusher to encode a new data-packet; = 0 no action
        dac_frame_sel = 2; // indicates which data-packet buffer is currently in use

unsigned int frame_time_cnt = 0; // counts the number of 125us intervals since last thermal sensor data poll; 125us intervals are generated by the TMR1GIF triggering

const unsigned int cal_value = 441; // calibration value resulting in a data-packet consisting of: SYNC SYMBOL0 SYMBOL1 SYMBOL2 SYMBOL3 SYMBOL2 SYMBOL1
                                    // placed in the beginning of a thermal data-frame and used by iOS app. for symbol threshold calibration



// initliaze system and ports
void init_sys()
{
    OSCCONbits.SPLLEN = 0; // Disable PLL
    OSCCONbits.IRCF = 0b1111; // HFINTOSC prescaler set for 16 Mhz FOSC
    OSCCONbits.SCS = 0b10; // select Internal oscillator as sys clock

    TRISA = 0b111111; // all PORTA pins are inputs
    TRISB = 0b10111111; // RB6 (SPI_SCK) is output; the rest of PORTB are inputs
    TRISC = 0b00111111; // RC7 (SPI_SDO), RC6 (SPI_SS) are outputs; the rest of PORTC are inputs
    LATC  = 0b11000000; // make SPI_SDO and SPI_SS pins HIGH

    ANSELA = 0;
    ANSELB = 0; // ALL pins Digital
    ANSELC = 0;
}

// initialize DAC module
void init_dac()
{
    DACCON0bits.DACOE1 = 1; // Enable DAC output on DACOUT1 (RC2)
    DACCON0bits.DACOE2 = 0; // Disable DAC output on DACOUT2 (RC3)
    DACCON0bits.D1PSS = 0;  // Select VDD as positive source for DAC
    DACCON0bits.DACEN = 1;  // Enable DAC module
}

// initialize Comparator1 module
void init_comp()
{
    FVRCONbits.CDAFVR = 0b01;  // Comparator FVR Buffer output is 1.024V
    FVRCONbits.FVREN = 1;      // Enable FVR

    CM1CON0bits.C1POL = 1;     // Comparator output is inverted
    CM1CON0bits.C1HYS = 1;     // Comparator hysteresis enabled
    CM1CON0bits.C1SYNC = 1;    // Comparator output to Timer1 and I/O pin is synchronous to changes on Timer1 clock source.
                               // Output updated on the falling edge of Timer1 clock source.

    CM1CON1bits.C1PCH = 0b10;  // C1VP connects to FVR
    CM1CON1bits.C1NCH = 0b011; // C1NP connects to C1IN3

    CM1CON0bits.C1ON = 1; // Enable Comparator module
}

// initialize Timer1 module
void init_tmr1()
{
    T1CONbits.TMR1CS = 0b01; // Timer1 clock is system clock (FOSC) = 16 Mhz
    T1CONbits.TMR1ON = 1;    // Enable Timer1
    
    T1GCONbits.TMR1GE = 1;  // Timer1 counting is controlled by the Timer1 gate function
    T1GCONbits.T1GPOL = 1;  // Timer1 gate is active-high (Timer1 counts when gate is high)
    T1GCONbits.T1GTM = 1;   // Timer1 Gate Toggle mode is enabled
    T1GCONbits.T1GSPM = 1;  // Timer1 Gate Single-Pulse mode is enabled and is controlling Timer1 gate
    T1GCONbits.T1GSS = 0b10;// Timer1 Gate Source: Comparator 1 optionally synchronized output (sync_C1OUT)
   
    TMR1GIE = 1;      // Enable Timer1 Gate Interrupt
    T1GGO_nDONE = 1;  // Timer1 gate single-pulse acquisition is ready, waiting for an edge
}

// initialize Timer2 module
void init_tmr2()
{
    T2CONbits.T2OUTPS = 0b0000; // 1:1 postascaler (redundant)
    T2CONbits.T2CKPS = 0b00;    // Prescaler is 1  (redundant)

    TMR2IE = 1; // Enable Timer2:PR2 match interrupt
}

// initialize D6T-1616L for measurement mode
char d6t_init()
{
    char i,
         input_data[5]; // stores SPI cmd response

    const char data[4]={0x01,0x80,0x00,0x81};  // cmd to put D6T-1616L in measurement mode (data bytes is encodeded LSB 1st)


    // initialize SPI module
    SSPCON1bits.CKP = 1; // 1 = Idle state for clock is a high level
    SSPCON1bits.SSPM = 0001; // SPI Master mode, clock = FOSC/16 = 1Mhz
    SSPEN = 1; // 1 = Enables serial port and configures SCK, SDO, SDI as the source of the serial port pins


    SPI_SS = 0; // Make SS pin LOW
    __delay_us(90); // Give time to D6T-1616L to react to SS change

    // send START command
    for (i=0; i<4; i++)
    {
        while(SSP1STATbits.BF);   // if SPI buffer full -> wait for it to become empty; blocking code! - should implement timeout
        SSPBUF = data[i];         // put data to be sent in the SPI buffer
        while (!SSP1STATbits.BF); // wait for reply byte to be transfered
        input_data[i] = SSPBUF;   // read the SPI buffer just to clear the BF flag (this is bogus data)
    }

    __delay_us(150); // Give time to D6T1616L to process command

    // Receive cmd response
    for (i=0; i<5; i++)
    {
        while(SSP1STATbits.BF);   // if SPI buffer full -> wait for it to become empty; blocking code! - should implement timeout
        SSPBUF = 0xFF;            // put (bogus) data to be sent in the SPI buffer
        while (!SSP1STATbits.BF); // wait for reply byte to be transfered; blocking code! - should implement timeout
        input_data[i] = SSPBUF;   // read the cmd response bytes
    }

    SPI_SS = 1; // Make SS pin back HIGH
    frame_time_cnt = 0; // Reset frame time counter; Poll the sensor after 250ms for a thermal data frame

    return input_data[1]; // return cmd response status (unused)
}

// get a thermal data frame from D6T-1616L
char d6t_get_frame(char *out_data)
{
    unsigned int i;

    char input_data[5]; // stores SPI cmd response

    const char data[4]={0x41,0x80,0x00,0xC1}; // 'Get Measurement' cmd (data bytes is encodeded LSB 1st)
    

    SPI_SS = 0; // Make SS pin LOW
    __delay_us(90); // Give time to D6T-1616L to react to SS change

    // send 'get measurement' cmd
    for (i=0; i<4; i++)
    {
        while(SSP1STATbits.BF);   // if SPI buffer full -> wait for it to become empty; blocking code! - should implement timeout
        SSPBUF = data[i];         // put data to be sent in the SPI buffer
        while (!SSP1STATbits.BF); // wait for reply byte to be transfered
        input_data[i] = SSPBUF;   // read the SPI buffer just to clear the BF flag (this is bogus data)
    }

    __delay_us(150); // Give time to D6T1616L to process command

    // Receive cmd response
    for (i=0; i<5; i++)
    {
        while(SSP1STATbits.BF);   // if SPI buffer full -> wait for it to become empty; blocking code! - should implement timeout
        SSPBUF = 0xFF;            // put (bogus) data to be sent in the SPI buffer
        while (!SSP1STATbits.BF); // wait for reply byte to be transfered; blocking code! - should implement timeout
        input_data[i] = SSPBUF;   // read the cmd response bytes
    }

    if (input_data[1] != 0)
        return input_data[1]; // If cmd response status is abnormal, abort; No thermal data is available

    // Read the thermal data
    for (i=0; i<520; i++)
    {
        while(SSP1STATbits.BF);   // if SPI buffer full -> wait for it to become empty; blocking code! - should implement timeout
        SSPBUF = 0xFF;            // put (bogus) data to be sent in the SPI buffer
        while (!SSP1STATbits.BF); // wait for reply byte to be transfered; blocking code! - should implement timeout
        input_data[i] = SSPBUF;   // read the thermal data bytes
    }

    SPI_SS = 1; // Make SS pin back HIGH
    frame_time_cnt = 0; // Reset frame time counter; Poll the sensor again after 250ms for a new thermal data frame

    return 0; // return with normal status (unused)
}

// encodes a thermal data frame and pushes it sequentially to the DAC buffers (on request by the sending routine)
void frame_encoder()
{
    int tmp_grp, // helper var
        i = -8;  // data-frame index

    char b15=0, 
         b13=0,
         b12=0,
         j,
         tmph, // helper var
         tmpl, // helper var
         tmp_byte, // helper var
         frame_sync, // signals that the data-packet is a FRAME-SYNC
         dac_buffer[14]; // temporary DAC buffer

    unsigned int chksum = 0, // stores the data-frame 12bit checksum
                 value,
                 format, // format of the thermal data in the data-frame
                 k;


    d6t_get_frame(d6t_frame); // get a new frame from D6T-1616L as it's ready



    // go through all MSBs of pixel thermal data
    // PX0_LSB:  | b0 | b1 | b2 | b3 | b4 | b5 | b6 | b7 |  *Least Significative Bit is leftmost; b4 to b0 - decimal part (1/2 to 1/32)
    // PX0_MSB:  | b8 | b9 | b10| b11| b12| b13| b14| b15|  *Least Significative Bit is leftmost; b14 to b5 - integer part (512 to 1), b15 - SIGN bit
    // ...
    // PX255_LSB
    // PX255_MSB
    for (k = 8; k < 520; k+=2)
    {
        tmp_byte = d6t_frame[k];

        if (!b15)
        {
            if bit_test(tmp_byte,0) // check if we have negative thermal data (b15 set); b15 is stored in bit0 of d6t_frame[k], where k is even
            {
                b15 = 1;
                if (b13) // if we also have data with b13 set, no need to look further (encoding can already be decided)
                   break;
            }
        }
        else if (b13) // if we also have data with b13 set, no need to look further (encoding can already be decided)
            break;


        if (!b13)
        {
            if (bit_test(tmp_byte, 2) && (!bit_test(tmp_byte,0))) // check if we have thermal data over 256*C (b13 set) but POSITIVE (b15 clear*); b13 is stored in bit2 of d6t_frame[k], where k is even
            {                                                     // * as negative data is stored in two's complement it'll falsely make use believe we have data over 256*C (b13 set)
                b13 = 1;
                if (b15) // if we also have negative data (b15 set), no need to look further (encoding can already be decided)
                   break;
            }
            else if (!b12)
            {
                if (bit_test(tmp_byte, 3) && (!bit_test(tmp_byte,0))) // check if we have thermal data over 128*C (b12 set) but POSITIVE (b15 clear*); b12 is stored in bit3 of d6t_frame[k], where k is even
                {                                                     // * as negative data is stored in two's complement it'll falsely make use believe we have data over 128*C (b12 set)
                    b12 = 1;
                }
            }

        }
        else if (b15) // if we also have negative data (b15 set), no need to look further (encoding can already be decided)
            break;
    }

    // NOTE THAT THE D6T-1616L CAN ACTUALLY MEASURE TEMPERATURES FROM -25 (OR LESS) UP TO 300*C!

    // as we only have 12bits available to send each pixel thermal data we need to 'auto-scale' in some less common cases
    if (b13 && b15)
        format = 192; //LESS FREQUENT: if we have both some 'negative values' and some 'positive values over 256*C' in the same frame -> we send data as: 1 sign bit, 9 integer bits, only the most significative 2 decimal bits -> -511.75 to 511.75 *C (0.25*C resolution)
    else if (b13)
        format = 93; // FREQUENT: if we have  some 'positive values over 256*C' in the frame -> we send data as: 9 integer bits, 3 most significative decimal bits -> 0 to 511.875 *C (0.0125*C resolution)
    else if (b12 && b15)
        format = 183; //LESS FREQUENT: if we have both some 'negative values' and some 'positive values over 128*C' in the same frame -> we send data as: 1 sign bit, 8 integer bits, only the most significative 3 decimal bits -> -255.875 to 255.875 *C (0.0125*C resolution)
    else if (b12)
        format = 84; // FREQUENT: if we have some 'positive values over 128*C' in the frame -> we send data as: 8 integer bits, only the most significative 4 decimal bits -> 0 to 255.9375 *C (0.0625*C resolution)
    else if (b15)
        format = 174; //FREQUENT: if we have some 'negative values' but 'no positive values over 128*C' -> we send data as: 1 sign bit, 7 integer bits, only the most significative 4 decimal bits -> -127.9375 to 127.9375 (0.0625*C resolution)
    else
        format = 75; // MOST FREQUENT: if all pixel thermal data is 'positive values under 128*C' -> we send data as: 8 integer bits, all 5 decimal bits -> 0 to 127.96875 (0.03125*C resolution)


    // data-frame encoding:
    // DATA-FRAME (sent 4 times /s):   | FRAME-SYNC | FRAME-SYNC | CALIBRATION | FORMAT | THERMAL-DATA0 | ... | THERMAL-DATA259 | CHECKSUM | FRAME-SYNC | FRAME-SYNC | = 267 x 12-bit data-packets
    while (i < 525)
    {
        if (i == -8)
            frame_sync = 1; // signal that this is a FRAME-SYNC DATA-PACKET (START of DATA-FRAME)
        else if (i == -6)
            frame_sync = 1; // signal that this is a FRAME-SYNC DATA-PACKET (START of DATA-FRAME)
        else if (i == -4)
            value = cal_value; // CALIBRATION DATA-PACKET; constant resulting in (SYNC SYMBOL0 SYMBOL1 SYMBOL2 SYMBOL3 SYMBOL2 SYMBOL1) DAC sequence - see defines on top
        else if (i == -2)
            value = format; // format that the thermal data is encoded to (hundreds: sign bit; tens: nr of integer bits; units: nr of decimal bits)
        else if (i == 4)
        {
            value = 0; // always 0
            i -=1;     // a re-align is needed as byte4 of thermal-data is only 8bits long
        }
        else if (i < 7)  // encode the Reference Temperature (sensor body), VDD of sensor, other unused 16-bit values;
        {
            tmph = d6t_frame[i+1]; // MSB of data
            tmpl = d6t_frame[i];   // LSB of data


            value = (unsigned int) tmpl << 4 | (tmph >> 4); // | b0 | b1 | b2 | b3 | b4 | b5 | b6 | b7 || b8 | b9 | b10 | b11 |   (always encode as 7 integer bits and 5 decimal bits); * LSB 1st
            // negative temperatures of TA not taken care yet!!!
        }
        else if (i < 519) // encode the pixel thermal data
        {
            tmph = d6t_frame[i+1]; // MSB of data
            tmpl = d6t_frame[i];   // LSB of data

            if (b13 && b15) // we have both some 'negative values' and some 'positive values over 256*C' in the same frame -> we send data as: 1 sign bit, 9 integer bits, only the most significative 2 decimal bits -> -511.75 to 511.75 *C (0.25*C resolution)
            {
                value = (unsigned int) (tmpl << 7) | (tmph >> 1); // | b3 | b4 | b5 | b6 | b7 || b8 | b9 | b10 | b11 | b12 | b13 | b14 |  *LSB 1st

                if (tmph & 1) // if this pixel measured a negative temperature (meaning b15, residing in bit0 of tmph is set)
                {
                    value ^= 4095; // complement the data for signed representation decoding (could also be done in the iOS app); 1 is added in the iOS app (more difficult to do here as values are stored LSB 1st)
                    value |= 1; // replace b14 (not used anyway) with S bit
                }
            }

            else if (b13) // we have  some 'positive values over 256*C' in the frame -> we send data as: 9 integer bits, 3 most significative decimal bits -> 0 to 511.875 *C (0.0125*C resolution)
                value = (unsigned int) (tmpl << 6) | (tmph >> 2); // | b2 | b3 | b4 | b5 | b6 | b7 || b8 | b9 | b10 | b11 | b12 | b13 |  *LSB 1st

            else if (b12 && b15) // we have both some 'negative values' and some 'positive values over 128*C' in the same frame -> we send data as: 1 sign bit, 8 integer bits, only the most significative 3 decimal bits -> -255.875 to 255.875 *C (0.0125*C resolution)
            {
                value = (unsigned int) (tmpl << 6) | (tmph >> 2); // | b2 | b3 | b4 | b5 | b6 | b7 || b8 | b9 | b10 | b11 | b12 | b13 |  *LSB 1st

                if (tmph & 1) // if this pixel measured a negative temperature (meaning b15, residing in bit0 of tmph is set)
                {
                    value ^= 4095; // complement the data for signed representation decoding (could also be done in the iOS app); 1 is added in the iOS app (more difficult to do here as values are stored LSB 1st)
                    value |= 1; // replace b13 (not used anyway) with S bit
                }
            }

            else if (b12) // we have some 'positive values over 128*C' in the frame -> we send data as: 8 integer bits, only the most significative 4 decimal bits -> 0 to 255.9375 *C (0.0625*C resolution)
                value = (unsigned int) (tmpl << 5) | (tmph >> 3); // | b1 | b2 | b3 | b4 | b5 | b6 | b7 || b8 | b9 | b10 | b11 | b12 |   *LSB 1st

            else if (b15) // we have some 'negative values' but 'no positive values over 128*C' -> we send data as: 1 sign bit, 7 integer bits, only the most significative 4 decimal bits -> -127.9375 to 127.9375 (0.0625*C resolution)
            {
                value = (unsigned int) (tmpl << 5) | (tmph >> 3); // | b1 | b2 | b3 | b4 | b5 | b6 | b7 || b8 | b9 | b10 | b11 | b12 |   *LSB 1st

                if (tmph & 1) // if this pixel measured a negative temperature (meaning b15, residing in bit0 of tmph is set)
                {
                    value ^= 4095; // complement the data for signed representation decoding (could also be done in the iOS app); 1 is added in the iOS app (more difficult to do here as values are stored LSB 1st)
                    value |= 1; // replace b11 with S bit
                }
            }

            else // all pixel thermal data is 'positive values under 128*C' -> we send data as: 8 integer bits, all 5 decimal bits -> 0 to 127.96875 (0.03125*C resolution)
                value = (unsigned int) tmpl << 4 | (tmph >> 4); // | b0 | b1 | b2 | b3 | b4 | b5 | b6 | b7 || b8 | b9 | b10 | b11 |   *LSB 1st
        }
        else if (i == 519)
        {
            value = chksum; // encode calculated data-frame checksum
        }
        else if (i == 521)
            frame_sync = 1; // signal that this is a FRAME-SYNC DATA-PACKET (END of DATA-FRAME)
        else if (i == 523)
            frame_sync = 1; // signal that this is a FRAME-SYNC DATA-PACKET (END of DATA-FRAME)

        i+=2;

        if ((!frame_sync) && (i != -2))
            chksum = (chksum + value) & 0xFFF; // calculate 12-bit checksum

        while (!dac_calc_new); // wait until new data encoding is requested

        dac_calc_new = 0;

        dac_buffer[0] = HS; // the 12bit data packets always start with a SYNC symbol
        dac_buffer[1] = LS; // the 12bit data packets always start with a SYNC symbol

        if (!frame_sync) // this is not a FRAME-SYNC data-packet, but actualy thermal data
        {
            for (j = 13; j > 1; j -= 2) // loop 6 time as we need to encode 12bit data into a 7block data-packet (1 block encoded already as SYNC symbol)
            {
                tmp_grp = value & 0b11; // encode groups of 2bits to symbols
                value = value >> 2; // shift the 2bits that have already been encoded

                if (tmp_grp == 0)      // if the 2bit group is 0 -> encode SYMBOL0
                {
                    dac_buffer[j] = L0;
                    dac_buffer[j - 1] = H0;
                }
                else if (tmp_grp == 1) // if the 2bit group is 1 -> encode SYMBOL1
                {
                    dac_buffer[j] = L1;
                    dac_buffer[j - 1] = H1;
                }
                else if (tmp_grp == 2) // if the 2bit group is 2 -> encode SYMBOL2
                {
                    dac_buffer[j] = L2;
                    dac_buffer[j - 1] = H2;
                }
                else                   // if the 2bit group is 3 -> encode SYMBOL3
                {
                    dac_buffer[j] = L3;
                    dac_buffer[j - 1] = H3;
                }
            }
            // * note that the 12bit data is still encoded as LSB 1st (as the checksum computation on receival in iOS app. needs to be computed on the same data for the checksums to match); 12bit data reversal (to MSB 1st) is done after, in the iOS app
        } 
        else // this is a FRAME-SYNC data-packet; all 7 blocks are SYNC symbols
        {
            frame_sync = 0;
            dac_buffer[0] = HS;
            dac_buffer[1] = LS;
            dac_buffer[2] = HS;
            dac_buffer[3] = LS;
            dac_buffer[4] = HS;
            dac_buffer[5] = LS;
            dac_buffer[6] = HS;
            dac_buffer[7] = LS;
            dac_buffer[8] = HS;
            dac_buffer[9] = LS;
            dac_buffer[10] = HS;
            dac_buffer[11] = LS;
            dac_buffer[12] = HS;
            dac_buffer[13] = LS;
        }

        // if one of the DAC buffers is currently in use, place the data-packet in the other one
        if (dac_frame_sel == 2)
            for (j = 0; j < 14; j++)
                dac_frame1[j] = dac_buffer[j];
        else
            for (j = 0; j < 14; j++)
                dac_frame2[j] = dac_buffer[j];
    }

}

void main()
{
    char data[64];

    __delay_ms(100);

    // initialize everything
    init_sys();
    init_dac();
    init_comp();
    init_tmr1();
    init_tmr2();
    d6t_init();
    
    PEIE = 1; // Enable all active peripheral interrupts
    GIE = 1;  // Enable all active interrupts
    
    // forever and ever :)
    while (1)
    {
        if (frame_time_cnt > 1999) // if 250ms (2000 x 125us intervals) have elapsed from last D6T-1616 data poll -> Then a new thermal-data frame is available
            frame_encoder(); // call the frame encoder
    }
}


// this is called everytime the DAC must change its state for Pulse Amplitude Modulation (PAM) signal output at 8000 Hz
//   - it's called 8000 times / s by the TMR1GIF triggering (controlled by Comparator1 being fed a 16000 Hz sine wave - produced by the iOS app.) - continuous period measurement (PIC16LF1459 datasheet, Page 186, Figure 20-6)
//   - called another 8000 times /s by the TMR2I triggering (interleaved with the TMR1GIF triggering) - PR2 set to match TMR2 exactly at the measured period
// as the continuos period measurement is done every two periods and the TMR2 interrupt is done every measured period, combining them results in triggering 16000 times / s -> the nr. of DAC state changes / s needed generate the 8000 Hz dual polarity PAM signal
//   * DAC state-change clocking is done with the sine wave generated by the iOS app. because this way it's in sync with iOS device's ADC sampling of mic. input (provided that a frequency divisor of the sampling rate is chosen for the sine wave)
//       - this is done in contrast to clocking the DAC state-change with a locally generated clock (derived from microcontroller's internal oscillator), which could result in clock drifting (compared to the iOS device's audio sampling clock)
void interrupt dac_clock_int(void)
{
    static char i,
                *dac_frame,
                count,
                dac_lvl; // helper var
  

    if (TMR2IF) // TMR2 to PR2 match interrupt (16000 Hz)
    {      
        DACCON1 = dac_lvl; // set DAC to the indicated boltage level (less instructions / faster if a single variable is used instead of referencing an element in an array)

        TMR2IF = 0; // clear TMR2 interrupt flag

        if (++count == 2) // trigger only once per '16000 Hz wave' period (the other triggering is done by TMR1GIF)
        {
            TMR2ON = 0; // stop TMR2
            TMR2 = 0;   // clear TMR2 counter
        }

        if (i != 14)
           dac_lvl = dac_frame[i++]; // store next DAC value of the data-packet to be sent (14 dual polarity values -> 7 symbol blocks: 1 sync symbol, 6 data symbols)
        else
        {
            // reloads the dac_frame with a new data-packet that has already been encoded by the frame_encoder
            //    * uses 2 buffers because while one is used to send the data in the dac_clock_int, the other one can already be reloaded with the next data-packet (while the encoding takes some time and we want to have it available immediately after the current data-packet has been sent)
            if (dac_frame_sel == 1) // if one buffer is currently used -> reload the next data-packet from the other buffer
            {
                dac_frame_sel = 2;
                dac_frame = dac_frame2;
            }
            else
            {
                dac_frame_sel = 1;
                dac_frame = dac_frame1; // if one buffer is currently used -> reload the next data-packet from the other buffer
            }

            dac_calc_new = 1; // signal the frame-encoder to calculate (encode) a new data-packet
            i = 0;
            dac_lvl = dac_frame[i++]; // load the first voltage level (of the new data-packet) in the DAC helper var (prepare it to be output)
        }

    }
    if (TMR1GIF) // period measurement interrupt (8000 HZ - every two periods of the sinewave)
    {
        TMR2ON = 1; // start TMR2
        DACCON1 = dac_lvl; // set DAC to the indicated boltage level (less instructions / faster if a single variable is used instead of referencing an element in an array)

        if (i != 14)
           dac_lvl = dac_frame[i++]; // store next DAC value of the data-packet to be sent (14 dual polarity values -> 7 symbol blocks: 1 sync symbol, 6 data symbols)

        PR2 = TMR1 >> 2; // set the PR2 to trigger (at TMR2 to PR2 match) to half-time of the last measured period

        TMR1 = 0; // clear the TMR1 counter
        count = 1;
        T1GGO_nDONE = 1; // prepare for a new period measurement
        TMR1GIF = 0; // clear TMR1 gate interrupt flag

        frame_time_cnt++; // another 125us period has passed
    }
}
